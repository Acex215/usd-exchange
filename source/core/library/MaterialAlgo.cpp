// SPDX-FileCopyrightText: Copyright (c) 2022-2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
// SPDX-License-Identifier: LicenseRef-NvidiaProprietary
//
// NVIDIA CORPORATION, its affiliates and licensors retain all intellectual
// property and proprietary rights in and to this material, related
// documentation and any modifications thereto. Any use, reproduction,
// disclosure or distribution of this material and related documentation
// without an express license agreement from NVIDIA CORPORATION or
// its affiliates is strictly prohibited.

#include "usdex/core/MaterialAlgo.h"

#include "usdex/core/StageAlgo.h"

#include <pxr/usd/usdShade/materialBindingAPI.h>
#include <pxr/usd/usdShade/tokens.h>

using namespace pxr;

namespace
{

// Warnings generated by USD 23.11
#if defined(ARCH_OS_WINDOWS) && PXR_VERSION < 2405
#pragma warning(push)
#pragma warning(disable : 4003) // not enough arguments for function-like macro invocation
#endif
// clang-format off
TF_DEFINE_PRIVATE_TOKENS(
    _tokens,
    ((upsId, "UsdPreviewSurface"))
    ((upsName, "PreviewSurface"))
    ((color, "diffuseColor"))
    ((metallic, "metallic"))
    ((opacity, "opacity"))
    ((roughness, "roughness"))
);
// clang-format on
// Warnings generated by USD 23.11
#if defined(ARCH_OS_WINDOWS) && PXR_VERSION < 2405
#pragma warning(pop)
#endif

float toLinear(float value)
{
    if (value <= 0.04045f)
    {
        return value / 12.92f;
    }
    else
    {
        float adjusted = (value + 0.055f) / 1.055f;
        return std::pow(adjusted, 2.4f);
    }
}

float fromLinear(float value)
{
    float test = value * 12.92f;
    if (test <= 0.04045f)
    {
        return test;
    }
    else
    {
        float scaled = std::pow(value, 1.0f / 2.4f);
        return (scaled * 1.055f) - 0.055f;
    }
}

} // namespace

UsdShadeMaterial usdex::core::createMaterial(UsdPrim parent, const std::string& name)
{
    // Early out if the proposed prim location is invalid
    std::string reason;
    if (!usdex::core::isEditablePrimLocation(parent, name, &reason))
    {
        TF_WARN("Unable to create UsdShadeMaterial due to an invalid location: %s", reason.c_str());
        return UsdShadeMaterial();
    }

    SdfPath materialPath = parent.GetPath().AppendChild(TfToken(name));
    UsdStagePtr stage = parent.GetStage();

    UsdShadeMaterial material = UsdShadeMaterial::Define(stage, materialPath);
    return material;
}

bool usdex::core::bindMaterial(UsdPrim prim, const UsdShadeMaterial& material)
{
    UsdPrim matPrim = material.GetPrim();
    if (!matPrim && !prim)
    {
        TF_WARN(
            "UsdPrim <%s> and UsdShadeMaterial <%s> are not valid, cannot bind material to prim",
            prim.GetPath().GetAsString().c_str(),
            material.GetPath().GetAsString().c_str()
        );
        return false;
    }
    if (!matPrim)
    {
        TF_WARN("UsdShadeMaterial <%s> is not valid, cannot bind material to prim", matPrim.GetPath().GetAsString().c_str());
        return false;
    }
    if (!prim)
    {
        TF_WARN("UsdPrim <%s> is not valid, cannot bind material to prim", prim.GetPath().GetAsString().c_str());
        return false;
    }
    UsdShadeMaterialBindingAPI materialBinding = UsdShadeMaterialBindingAPI::Apply(prim);
    return materialBinding.Bind(material);
}

UsdShadeShader usdex::core::computeEffectivePreviewSurfaceShader(const UsdShadeMaterial& material)
{
    if (!material)
    {
        return UsdShadeShader();
    }

    return material.ComputeSurfaceSource({ UsdShadeTokens->universalRenderContext });
}

UsdShadeMaterial usdex::core::definePreviewMaterial(
    UsdStagePtr stage,
    const SdfPath& path,
    const GfVec3f& color,
    const float opacity,
    const float roughness,
    const float metallic
)
{
    // Early out if the proposed prim location is invalid
    std::string reason;
    if (!usdex::core::isEditablePrimLocation(stage, path, &reason))
    {
        TF_RUNTIME_ERROR("Unable to define UsdShadeMaterial due to an invalid location: %s", reason.c_str());
        return UsdShadeMaterial();
    }

    // The opacity value must be within the defined min/max range
    if (opacity < 0.0 || opacity > 1.0)
    {
        reason = TfStringPrintf("Opacity value %f is outside range [0.0 - 1.0].", opacity);
        TF_RUNTIME_ERROR(
            "Unable to define UsdShadeMaterial at \"%s\" due to an invalid shader parameter value: %s",
            path.GetAsString().c_str(),
            reason.c_str()
        );
        return UsdShadeMaterial();
    }

    // The roughness value must be within the defined min/max range
    if (roughness < 0.0 || roughness > 1.0)
    {
        reason = TfStringPrintf("Roughness value %f is outside range [0.0 - 1.0].", roughness);
        TF_RUNTIME_ERROR(
            "Unable to define UsdShadeMaterial at \"%s\" due to an invalid shader parameter value: %s",
            path.GetAsString().c_str(),
            reason.c_str()
        );
        return UsdShadeMaterial();
    }

    // The metallic value must be within the defined min/max range
    if (metallic < 0.0 || metallic > 1.0)
    {
        reason = TfStringPrintf("Metallic value %f is outside range [0.0 - 1.0].", metallic);
        TF_RUNTIME_ERROR(
            "Unable to define UsdShadeMaterial at \"%s\" due to an invalid shader parameter value: %s",
            path.GetAsString().c_str(),
            reason.c_str()
        );
        return UsdShadeMaterial();
    }

    // Define the material. We do not use usdex::core::createMaterial here to avoid double validations.
    UsdShadeMaterial material = UsdShadeMaterial::Define(stage, path);
    if (!material)
    {
        TF_RUNTIME_ERROR("Unable to define UsdShadeMaterial at \"%s\"", path.GetAsString().c_str());
        return UsdShadeMaterial();
    }

    // Early out if the proposed child shader prim location is invalid
    if (!usdex::core::isEditablePrimLocation(material.GetPrim(), _tokens->upsName, &reason))
    {
        // FUTURE: Cleanup the material prim we just created
        TF_RUNTIME_ERROR(
            "Unable to define UsdShadeShader named \"%s\" as a child of \"%s\"",
            _tokens->upsName.GetString().c_str(),
            path.GetAsString().c_str()
        );
        return UsdShadeMaterial();
    }

    // Explicitly author the specifier and type name
    UsdPrim prim = material.GetPrim();
    prim.SetSpecifier(SdfSpecifierDef);
    prim.SetTypeName(prim.GetTypeName());

    // Define the surface shader to be used in the universal rendering context
    SdfPath shaderPath = path.AppendChild(_tokens->upsName);
    UsdShadeShader shader = UsdShadeShader::Define(stage, shaderPath);
    shader.SetShaderId(_tokens->upsId);
    material.CreateSurfaceOutput().ConnectToSource(shader.CreateOutput(UsdShadeTokens->surface, SdfValueTypeNames->Token));
    material.CreateDisplacementOutput().ConnectToSource(shader.CreateOutput(UsdShadeTokens->displacement, SdfValueTypeNames->Token));

    // Create default shader inputs to produce a physically based rendering result with the supplied values
    shader.CreateInput(_tokens->color, SdfValueTypeNames->Color3f).Set(color);
    shader.CreateInput(_tokens->opacity, SdfValueTypeNames->Float).Set(opacity);
    shader.CreateInput(_tokens->roughness, SdfValueTypeNames->Float).Set(roughness);
    shader.CreateInput(_tokens->metallic, SdfValueTypeNames->Float).Set(metallic);

    return material;
}

UsdShadeMaterial usdex::core::definePreviewMaterial(
    UsdPrim parent,
    const std::string& name,
    const GfVec3f& color,
    const float opacity,
    const float roughness,
    const float metallic
)
{
    // Early out if the proposed prim location is invalid
    std::string reason;
    if (!usdex::core::isEditablePrimLocation(parent, name, &reason))
    {
        TF_RUNTIME_ERROR("Unable to define UsdShadeMaterial due to an invalid location: %s", reason.c_str());
        return UsdShadeMaterial();
    }

    // Call overloaded function
    UsdStageWeakPtr stage = parent.GetStage();
    const SdfPath path = parent.GetPath().AppendChild(TfToken(name));
    return usdex::core::definePreviewMaterial(stage, path, color, opacity, roughness, metallic);
}

GfVec3f usdex::core::sRgbToLinear(const GfVec3f& color)
{
    return GfVec3f(toLinear(color[0]), toLinear(color[1]), toLinear(color[2]));
}

GfVec3f usdex::core::linearToSrgb(const GfVec3f& color)
{
    return GfVec3f(fromLinear(color[0]), fromLinear(color[1]), fromLinear(color[2]));
}
