// SPDX-FileCopyrightText: Copyright (c) 2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//

#include "usdex/core/AssetStructure.h"

#include "usdex/core/LayerAlgo.h"
#include "usdex/core/NameAlgo.h"
#include "usdex/core/StageAlgo.h"

#include <pxr/base/tf/stringUtils.h>
#include <pxr/usd/ar/resolver.h>
#include <pxr/usd/kind/registry.h>
#include <pxr/usd/sdf/copyUtils.h>
#include <pxr/usd/sdf/spec.h>
#include <pxr/usd/usd/modelAPI.h>
#include <pxr/usd/usd/payloads.h>
#include <pxr/usd/usd/prim.h>
#include <pxr/usd/usd/primRange.h>
#include <pxr/usd/usdGeom/bboxCache.h>
#include <pxr/usd/usdGeom/imageable.h>
#include <pxr/usd/usdGeom/metrics.h>
#include <pxr/usd/usdGeom/modelAPI.h>
#include <pxr/usd/usdGeom/scope.h>
#include <pxr/usd/usdGeom/tokens.h>

#include <filesystem>

using namespace pxr;

namespace
{
// Warnings generated by USD 23.11
#if defined(ARCH_OS_WINDOWS) && PXR_VERSION < 2405
#pragma warning(push)
#pragma warning(disable : 4003) // not enough arguments for function-like macro invocation
// clang-format off
TF_DEFINE_PRIVATE_TOKENS(
    _tokens,
    (Asset)
    (Contents)
    (Geometry)
    (Library)
    (Materials)
    (Physics)
    (Textures)
    (Payload)
    ((Empty, ""))
);
// clang-format on
#pragma warning(pop)
#else
// clang-format off
TF_DEFINE_PRIVATE_TOKENS(
    _tokens,
    (Asset)
    (Contents)
    (Geometry)
    (Library)
    (Materials)
    (Physics)
    (Textures)
    (Payload)
    ((Empty, ""))
);
// clang-format on
#endif


//! Compute the relative identifier from an anchor identifier to a source identifier
//!
//! This function computes a relative path from the anchor identifier to the source identifier.
//! If no relative path can be computed (e.g., different drives on Windows), the source identifier
//! is returned as-is. Relative paths are always anchored with "./" and use forward slashes.
//!
//! @param sourceIdentifier The source identifier to compute the relative path to
//! @param anchorIdentifier The anchor identifier to compute the relative path from
//! @returns The relative identifier string, or the source identifier if no relative path is possible
std::string getRelativeIdentifier(const std::string& sourceIdentifier, const std::string& anchorIdentifier)
{
    // Handle empty strings
    if (sourceIdentifier.empty())
    {
        return sourceIdentifier;
    }

    if (anchorIdentifier.empty())
    {
        return sourceIdentifier;
    }

    std::filesystem::path source(sourceIdentifier);
    std::filesystem::path anchor(anchorIdentifier);

    // If either path is not an absolute file path, return the source as-is
    if (!source.has_filename() || !source.is_absolute())
    {
        TF_WARN("Unable to compute relative identifier, source identifier is not an absolute file path: %s", sourceIdentifier.c_str());
        return sourceIdentifier;
    }

    if (!anchor.has_filename() || !anchor.is_absolute())
    {
        TF_WARN("Unable to compute relative identifier, anchor identifier is not an absolute file path: %s", anchorIdentifier.c_str());
        return sourceIdentifier;
    }

    // Use proximate to compute relative path from anchor directory to source
    std::filesystem::path relativePath = std::filesystem::proximate(source, anchor.parent_path());

    // If proximate returns an absolute path, it means no relative path could be computed
    if (relativePath.is_absolute())
    {
        return sourceIdentifier;
    }

    // Convert to generic string format (forward slashes) and add "./" prefix
    std::string result = relativePath.generic_string();

    // Ensure the path starts with "./"
    if (!result.empty() && result[0] != '.')
    {
        result = "./" + result;
    }

    return result;
}

//! Common implementation for defineReference and definePayload (stage, path) versions
//!
//! @param stage The stage on which to define the reference/payload
//! @param path The absolute prim path at which to define the reference/payload
//! @param source The source prim to reference/payload
//! @param outRelativeIdentifier The relative identifier of the source prim
//! @param isInternal Whether the reference/payload is internal or external
//! @returns The newly created prim. Returns an invalid prim on error.
UsdPrim createReferencePayloadPrim(
    UsdStagePtr stage,
    const SdfPath& path,
    UsdPrim source,
    std::string& outRelativeIdentifier,
    bool& outIsInternal,
    bool& outSourceIsDefaultPrim
)
{
    // Early out if the proposed prim location is invalid
    std::string reason;
    if (!usdex::core::isEditablePrimLocation(stage, path, &reason))
    {
        TF_RUNTIME_ERROR("Unable to define reference/payload due to an invalid location: %s", reason.c_str());
        return UsdPrim();
    }

    // Early out if the source prim is invalid
    if (!source)
    {
        TF_RUNTIME_ERROR("Unable to define reference/payload due to an invalid source prim");
        return UsdPrim();
    }

    // Get the source and stage layers so as not to accidentally use the stage's root layer
    SdfLayerHandle sourceLayer = source.GetStage()->GetRootLayer();
    SdfLayerHandle stageLayer = stage->GetEditTarget().GetLayer();

    // Early out if either stage is anonymous
    if (stageLayer->IsAnonymous())
    {
        TF_RUNTIME_ERROR("Unable to define reference/payload due to an anonymous referencing stage");
        return UsdPrim();
    }

    if (sourceLayer->IsAnonymous())
    {
        TF_RUNTIME_ERROR("Unable to define reference/payload due to an anonymous source stage");
        return UsdPrim();
    }

    // Ensure that the layer identifiers are resolved to absolute paths
    ArResolver& resolver = ArGetResolver();
    ArResolvedPath sourceResolvedPath = resolver.Resolve(sourceLayer->GetIdentifier());
    if (!sourceResolvedPath)
    {
        TF_RUNTIME_ERROR("Unable to define reference/payload due to an invalid source layer identifier: %s", sourceLayer->GetIdentifier().c_str());
        return UsdPrim();
    }

    ArResolvedPath stageResolvedPath = resolver.Resolve(stageLayer->GetIdentifier());
    if (!stageResolvedPath)
    {
        TF_RUNTIME_ERROR("Unable to define reference/payload due to an invalid stage layer identifier: %s", stageLayer->GetIdentifier().c_str());
        return UsdPrim();
    }

    // If the source prim and reference are in the same stage, we can use an internal reference/payload
    if (stageResolvedPath.GetPathString() == sourceResolvedPath.GetPathString())
    {
        outIsInternal = true;
        outRelativeIdentifier = "";
        if (path == source.GetPath())
        {
            TF_RUNTIME_ERROR("Unable to define reference/payload pointing to itself: \"%s\"", path.GetAsString().c_str());
            return UsdPrim();
        }
    }
    else
    {
        outIsInternal = false;
        // Compute the relative identifier between the stage's edit target and the source stage
        outRelativeIdentifier = ::getRelativeIdentifier(sourceResolvedPath.GetPathString(), stageResolvedPath.GetPathString());
    }

    if (source.GetPath() == source.GetStage()->GetDefaultPrim().GetPath())
    {
        outSourceIsDefaultPrim = true;
    }

    // Check if the prim is already defined
    UsdPrim existingPrim = stage->GetPrimAtPath(path);
    if (existingPrim)
    {
        // Set the specifier and type name from the source
        existingPrim.SetSpecifier(source.GetSpecifier());
        existingPrim.SetTypeName(source.GetTypeName());
        return existingPrim;
    }

    // Create a scope prim with the path
    UsdGeomScope scope = usdex::core::defineScope(stage, path);
    if (!scope)
    {
        return UsdPrim();
    }

    UsdPrim newPrim = scope.GetPrim();

    // Set the specifier and type name from the source
    newPrim.SetSpecifier(source.GetSpecifier());
    newPrim.SetTypeName(source.GetTypeName());

    return newPrim;
}

bool getReferencePayloadPrimPath(UsdPrim parent, UsdPrim source, std::optional<std::string_view> name, SdfPath& outPrimPath)
{
    if (!source)
    {
        TF_RUNTIME_ERROR("Unable to define reference/payload due to an invalid source prim");
        return false;
    }

    std::string primName = name.has_value() ? std::string(name.value()) : source.GetName().GetString();

    std::string reason;
    if (!usdex::core::isEditablePrimLocation(parent, primName, &reason))
    {
        TF_RUNTIME_ERROR("Unable to define reference/payload due to an invalid location: %s", reason.c_str());
        return false;
    }

    outPrimPath = parent.GetPath().AppendChild(TfToken(primName));
    return true;
}

//! Set the kind of a prim and all its descendants to component
//!
//! If any descendant is a component, it is set to subcomponent
//! If any descendant has an authored kind that is not component, it is set to an empty token
void createAssetComponent(UsdPrim prim)
{
    UsdModelAPI(prim).SetKind(KindTokens->component);
    for (UsdPrim descendant : UsdPrimRange(prim))
    {
        if (descendant == prim)
        {
            continue;
        }

        UsdModelAPI model = UsdModelAPI(descendant);
        TfToken currentKind;
        bool hasAuthoredKind = model.GetKind(&currentKind);
        if (currentKind == KindTokens->component)
        {
            bool success = model.SetKind(KindTokens->subcomponent);
            if (!success)
            {
                TF_WARN("Unable to set the kind of \"%s\" to subcomponent", descendant.GetPath().GetAsString().c_str());
            }
        }
        else if (hasAuthoredKind)
        {
            bool success = model.SetKind(_tokens->Empty);
            if (!success)
            {
                TF_WARN("Unable to clear the kind of \"%s\"", descendant.GetPath().GetAsString().c_str());
            }
        }
    }
}
} // namespace

UsdGeomScope usdex::core::defineScope(UsdStagePtr stage, const SdfPath& path)
{
    // Early out if the proposed prim location is invalid
    std::string reason;
    if (!usdex::core::isEditablePrimLocation(stage, path, &reason))
    {
        TF_RUNTIME_ERROR("Unable to define UsdGeomScope due to an invalid location: %s", reason.c_str());
        return UsdGeomScope();
    }

    // Define the Scope and check that this was successful
    UsdGeomScope scope = UsdGeomScope::Define(stage, path);
    if (!scope)
    {
        TF_RUNTIME_ERROR("Unable to define UsdGeomScope at \"%s\"", path.GetAsString().c_str());
        return UsdGeomScope();
    }

    // Explicitly author the specifier and type name
    UsdPrim prim = scope.GetPrim();
    prim.SetSpecifier(SdfSpecifierDef);
    prim.SetTypeName(prim.GetTypeName());

    return scope;
}

UsdGeomScope usdex::core::defineScope(UsdPrim parent, const std::string& name)
{
    // Early out if the proposed prim location is invalid
    std::string reason;
    if (!usdex::core::isEditablePrimLocation(parent, name, &reason))
    {
        TF_RUNTIME_ERROR("Unable to define UsdGeomScope due to an invalid location: %s", reason.c_str());
        return UsdGeomScope();
    }

    // Call overloaded function
    UsdStageWeakPtr stage = parent.GetStage();
    const SdfPath path = parent.GetPath().AppendChild(TfToken(name));
    return usdex::core::defineScope(stage, path);
}

UsdGeomScope usdex::core::defineScope(UsdPrim prim)
{
    if (!prim)
    {
        TF_RUNTIME_ERROR("Unable to define UsdGeomScope due to an invalid prim");
        return UsdGeomScope();
    }

    return usdex::core::defineScope(prim.GetStage(), prim.GetPath());
}

const TfToken& usdex::core::getAssetToken()
{
    return _tokens->Asset;
}

const TfToken& usdex::core::getContentsToken()
{
    return _tokens->Contents;
}

const TfToken& usdex::core::getGeometryToken()
{
    return _tokens->Geometry;
}

const TfToken& usdex::core::getLibraryToken()
{
    return _tokens->Library;
}

const TfToken& usdex::core::getMaterialsToken()
{
    return _tokens->Materials;
}

const TfToken& usdex::core::getPayloadToken()
{
    return _tokens->Payload;
}

const TfToken& usdex::core::getPhysicsToken()
{
    return _tokens->Physics;
}

const TfToken& usdex::core::getTexturesToken()
{
    return _tokens->Textures;
}

UsdStageRefPtr usdex::core::createAssetPayload(
    pxr::UsdStagePtr stage,
    const std::string& format,
    const pxr::SdfLayer::FileFormatArguments& fileFormatArgs
)
{
    if (!stage)
    {
        TF_WARN("Unable to create asset payload stage due to an invalid asset stage");
        return nullptr;
    }

    if (stage->GetRootLayer()->IsAnonymous())
    {
        TF_WARN("Unable to create asset payload stage due to an anonymous asset stage");
        return nullptr;
    }

    ArResolver& resolver = ArGetResolver();
    std::string relativeIdentifier = TfStringPrintf(
        "./%s/%s.%s",
        usdex::core::getPayloadToken().GetText(),
        usdex::core::getContentsToken().GetText(),
        format.c_str()
    );
    std::string identifier = resolver.CreateIdentifier(relativeIdentifier, resolver.Resolve(stage->GetRootLayer()->GetIdentifier()));

    UsdStageRefPtr payloadStage = usdex::core::createStage(
        identifier,
        stage->GetDefaultPrim().GetName(),
        UsdGeomGetStageUpAxis(stage),
        UsdGeomGetStageMetersPerUnit(stage),
        usdex::core::getLayerAuthoringMetadata(stage->GetRootLayer()),
        fileFormatArgs
    );
    if (!payloadStage)
    {
        TF_WARN("Unable to create asset payload stage");
        return nullptr;
    }

    // Copy the asset stage's default prim to the asset payload stage
    bool success = SdfCopySpec(
        stage->GetRootLayer(),
        stage->GetDefaultPrim().GetPath(),
        payloadStage->GetRootLayer(),
        payloadStage->GetDefaultPrim().GetPath()
    );
    if (!success)
    {
        TF_WARN("Unable to copy the asset stage's default prim to the asset payload stage");
        return nullptr;
    }

    return payloadStage;
}

UsdStageRefPtr usdex::core::addAssetLibrary(
    UsdStagePtr stage,
    const std::string& name,
    const std::string& format,
    const pxr::SdfLayer::FileFormatArguments& fileFormatArgs
)
{
    if (!stage)
    {
        TF_WARN("Unable to add asset library due to an invalid payload stage");
        return nullptr;
    }

    if (stage->GetRootLayer()->IsAnonymous())
    {
        TF_WARN("Unable to add asset library due to an anonymous payload stage");
        return nullptr;
    }

    ArResolver& resolver = ArGetResolver();
    std::string relativeIdentifier = TfStringPrintf("./%s%s.%s", name.c_str(), usdex::core::getLibraryToken().GetText(), format.c_str());
    std::string identifier = resolver.CreateIdentifier(relativeIdentifier, resolver.Resolve(stage->GetRootLayer()->GetIdentifier()));

    UsdStageRefPtr libraryStage = usdex::core::createStage(
        identifier,
        usdex::core::getValidPrimName(name),
        UsdGeomGetStageUpAxis(stage),
        UsdGeomGetStageMetersPerUnit(stage),
        usdex::core::getLayerAuthoringMetadata(stage->GetRootLayer()),
        fileFormatArgs
    );

    if (!libraryStage)
    {
        TF_WARN("Unable to create a new stage for the asset library \"%s\"", name.c_str());
        return nullptr;
    }

    // Create a scope using the existing defineScope function (defineScope will report errors)
    UsdGeomScope scope = usdex::core::defineScope(libraryStage->GetPseudoRoot(), name);
    if (!scope)
    {
        return nullptr;
    }

    // Set the specifier to class
    scope.GetPrim().SetSpecifier(SdfSpecifierClass);
    return libraryStage;
}

UsdStageRefPtr usdex::core::addAssetContent(
    UsdStagePtr stage,
    const std::string& name,
    const std::string& format,
    const pxr::SdfLayer::FileFormatArguments& fileFormatArgs,
    bool prependLayer,
    bool createScope
)
{
    if (!stage)
    {
        TF_WARN("Unable to add asset content due to an invalid payload stage");
        return nullptr;
    }

    if (stage->GetRootLayer()->IsAnonymous())
    {
        TF_WARN("Unable to add asset content due to an anonymous payload stage");
        return nullptr;
    }

    ArResolver& resolver = ArGetResolver();
    std::string relativeIdentifier = TfStringPrintf("./%s.%s", name.c_str(), format.c_str());
    std::string identifier = resolver.CreateIdentifier(relativeIdentifier, resolver.Resolve(stage->GetRootLayer()->GetIdentifier()));

    UsdPrim defaultPrim = stage->GetDefaultPrim();
    if (!defaultPrim)
    {
        TF_WARN("Unable to add asset content due to an invalid default prim");
        return nullptr;
    }

    UsdStageRefPtr contentStage = usdex::core::createStage(
        identifier,
        defaultPrim.GetName(),
        UsdGeomGetStageUpAxis(stage),
        UsdGeomGetStageMetersPerUnit(stage),
        usdex::core::getLayerAuthoringMetadata(stage->GetRootLayer()),
        fileFormatArgs
    );
    if (!contentStage)
    {
        TF_WARN("Unable to create a new stage for the asset content");
        return nullptr;
    }

    SdfSubLayerProxy subLayerPaths = stage->GetRootLayer()->GetSubLayerPaths();
    if (prependLayer)
    {
        subLayerPaths.insert(subLayerPaths.begin(), relativeIdentifier);
    }
    else
    {
        subLayerPaths.push_back(relativeIdentifier);
    }
    bool success = SdfCopySpec(
        stage->GetRootLayer(),
        stage->GetDefaultPrim().GetPath(),
        contentStage->GetRootLayer(),
        contentStage->GetDefaultPrim().GetPath()
    );
    if (!success)
    {
        TF_WARN("Unable to copy the asset stage's default prim to the asset content stage");
        return nullptr;
    }
    if (createScope)
    {
        UsdGeomScope scope = usdex::core::defineScope(contentStage->GetDefaultPrim(), name);
        if (!scope)
        {
            TF_WARN("Unable to create a scope in the asset content stage");
            return nullptr;
        }
    }

    return contentStage;
}

bool usdex::core::addAssetInterface(UsdStagePtr stage, const UsdStagePtr source)
{
    if (!stage)
    {
        TF_WARN("Unable to add asset interface due to an invalid stage");
        return false;
    }

    if (!source)
    {
        TF_WARN("Unable to add asset interface due to an invalid source stage");
        return false;
    }

    if (stage->GetRootLayer()->IsAnonymous())
    {
        TF_WARN("Unable to add asset interface due to an anonymous stage");
        return false;
    }

    if (source->GetRootLayer()->IsAnonymous())
    {
        TF_WARN("Unable to add asset interface due to an anonymous source stage");
        return false;
    }

    usdex::core::configureStage(
        stage,
        source->GetDefaultPrim().GetName(),
        UsdGeomGetStageUpAxis(source),
        UsdGeomGetStageMetersPerUnit(source),
        usdex::core::getLayerAuthoringMetadata(source->GetRootLayer())
    );
    bool success = SdfCopySpec(source->GetRootLayer(), source->GetDefaultPrim().GetPath(), stage->GetRootLayer(), stage->GetDefaultPrim().GetPath());
    if (!success)
    {
        TF_WARN("Unable to copy the source stage's default prim to the stage");
        return false;
    }

    UsdPrim root = stage->GetDefaultPrim();

    // Make the payload in the stage pointing to the source stage
    UsdPrim payload = usdex::core::definePayload(stage, root.GetPath(), source->GetDefaultPrim());
    if (!payload)
    {
        TF_WARN("Unable to define payload in the stage");
        return false;
    }

    // annotate the asset interface
    UsdModelAPI model = UsdModelAPI(root);
    model.SetAssetName(usdex::core::computeEffectiveDisplayName(root));
    ::createAssetComponent(root);

    UsdGeomModelAPI geomModel = UsdGeomModelAPI::Apply(root);
    if (!geomModel)
    {
        TF_WARN("Unable to apply the UsdGeomModelAPI to the default prim");
        return false;
    }

    UsdGeomBBoxCache bboxCache(UsdTimeCode::Default(), UsdGeomImageable(root).GetOrderedPurposeTokens());
    success = geomModel.SetExtentsHint(geomModel.ComputeExtentsHint(bboxCache));
    if (!success)
    {
        TF_WARN("Unable to set the extents hint for the default prim");
        return false;
    }

    return true;
}

UsdPrim usdex::core::defineReference(UsdStagePtr stage, const SdfPath& path, const UsdPrim& source)
{
    // Create the common prim structure and get the relative identifier
    std::string relativeIdentifier;
    bool isInternal = false;
    bool sourceIsDefaultPrim = false;
    UsdPrim newPrim = ::createReferencePayloadPrim(stage, path, source, relativeIdentifier, isInternal, sourceIsDefaultPrim);
    if (!newPrim)
    {
        return UsdPrim();
    }

    // Add the reference with relative path
    if (isInternal)
    {
        newPrim.GetReferences().AddInternalReference(source.GetPath());
    }
    else if (sourceIsDefaultPrim)
    {
        newPrim.GetReferences().AddReference(relativeIdentifier);
    }
    else
    {
        newPrim.GetReferences().AddReference(relativeIdentifier, source.GetPath());
    }

    return newPrim;
}

UsdPrim usdex::core::defineReference(UsdPrim parent, const UsdPrim& source, std::optional<std::string_view> name)
{
    SdfPath path;
    if (!::getReferencePayloadPrimPath(parent, source, name, path))
    {
        return UsdPrim();
    }
    return usdex::core::defineReference(parent.GetStage(), path, source);
}

UsdPrim usdex::core::definePayload(UsdStagePtr stage, const SdfPath& path, const UsdPrim& source)
{
    // Create the common prim structure and get the relative identifier
    std::string relativeIdentifier;
    bool isInternal = false;
    bool sourceIsDefaultPrim = false;
    UsdPrim newPrim = ::createReferencePayloadPrim(stage, path, source, relativeIdentifier, isInternal, sourceIsDefaultPrim);
    if (!newPrim)
    {
        return UsdPrim();
    }

    // Add the payload with relative path
    if (isInternal)
    {
        newPrim.GetPayloads().AddInternalPayload(source.GetPath());
    }
    else if (sourceIsDefaultPrim)
    {
        newPrim.GetPayloads().AddPayload(relativeIdentifier);
    }
    else
    {
        newPrim.GetPayloads().AddPayload(relativeIdentifier, source.GetPath());
    }

    return newPrim;
}

UsdPrim usdex::core::definePayload(UsdPrim parent, const UsdPrim& source, std::optional<std::string_view> name)
{
    SdfPath path;
    if (!::getReferencePayloadPrimPath(parent, source, name, path))
    {
        return UsdPrim();
    }
    return usdex::core::definePayload(parent.GetStage(), path, source);
}
